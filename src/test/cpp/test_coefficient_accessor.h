#include "../../main/cpp/coefficient_accessor.h"
#include "gtest/gtest.h"
#include <stdlib.h>
#include <time.h>

/**
 * Provides JPEG Coefficients from an array given.
 */
class DummyCoefficientsProvider : public JPEGCoefficientsProvider {
 public:
  /**
   * CTOR.
   * @param arr the array that will be provided to any who ask.
   */
  DummyCoefficientsProvider(JBLOCKARRAY arr) : array(arr) { }
  virtual JBLOCKARRAY getCoefficients(const JPEGComponent *comp) const {
    return array;
  }
 private:
  /**
   * The array to return.
   */
  JBLOCKARRAY array;
};

class CoefficientAccessorTest : public ::testing::Test {
 protected:
  /**
   * Create a JBLOCKARRAY containing a sequence of numbers, with the dimensions
   * given.
   * @param rows the number of rows of blocks to have
   * @param cols the number of columns of blocks to have
   * @param c a pointer to the value of first coefficient. At the end will
   *    point to the value of final coefficient + 1.
   */
  JBLOCKARRAY createBlockArray(int rows, int cols, unsigned int *c) {
    const int size = 64;
    int row, col, i;
    JBLOCKARRAY retval = (JBLOCKARRAY) malloc(sizeof(JCOEF **) * rows);
    for(row = 0; row < rows; row++) {
      retval[row] = new JCOEF[cols][64];
      for(col = 0; col < cols; col++) {
        for(i = 0; i < size; i++, (*c)++) {
          retval[row][col][i] = (*c);
        }
      }
    }
    return retval;
  }

  /**
   * Create a number of block arrays with random coefficients.
   * @param number the number of block arrays to create
   * @param rows array where rows[n] = number of rows in the nth block array
   * @param cols array where cols[n] = number of cols in the nth block array
   * @param testIndices an array of indices whose values should be recorded.
   *    Should be sorted!
   * @param sampleSize the number of entries in the testIndices array
   * @param values the values recorded for the indices given in testIndices.
   */
  JBLOCKARRAY *createRandomBlockArrays(int number, int *rows, int *cols,
      const unsigned int *testIndices, int sampleSize, JCOEF *values) {
    JBLOCKARRAY *retval = (JBLOCKARRAY *) malloc(sizeof(JBLOCKARRAY) * number);
    int n;
    const int size = 64;
    int row, col, i, j = 0;
    unsigned int c = 0;
    srand(time(NULL));
    for(n = 0; n < number; ++n) {
      retval[n] = (JBLOCKARRAY) malloc(sizeof(JCOEF **) * rows[n]);
      JBLOCKARRAY arr = retval[n];
      for(row = 0; row < rows[n]; ++row) {
        arr[row] = new JCOEF[cols[n]][64];
        for(col = 0; col < cols[n]; ++col) {
          for(i = 0; i < size; ++i, ++c) {
            JCOEF val = (rand() % 65534) - 32767;
            if(testIndices[j] == c && j < sampleSize) {
              values[j] = val;
              ++j;
            }
            arr[row][col][i] = val;
          }
        }
      }
    }
    return retval;
  }

  /**
   * Delete a JBLOCKARRAY allocated by this class.
   * @param blocks the doomed array.
   * @param rows the number of rows in the array
   */
  void deleteBlockArray(JBLOCKARRAY blocks, int rows) {
    int row;
    for(row = 0; row < rows; ++row) {
      delete (blocks[row]);
    }
    free(blocks);
  }
};

/**
 * Basic test to ensure that the accessor works, when dealing with a single
 * component.
 */
TEST_F(CoefficientAccessorTest, TestAccessSingleComponent) {
  const int rows = 16, cols = 16, size = 64;
  unsigned int c = 0;
  int i;
  JBLOCKARRAY blocks = createBlockArray(rows, cols, &c);
  DummyCoefficientsProvider p(blocks);
  JPEGComponent comp(cols, rows, cols * 8, rows * 8, 0, &p);
  JPEGComponent* arr[1] = { &comp };
  CoefficientAccessor acc(arr, 1);
  /* Here's the deal: because of the way this stuff was generated, the indeces
   * are equal to their corresponding coefficients, so we can test this pretty
   * easily by getting 10 coefficients. If you think this sounds like it'll
   * allow a ton of bugs through, you're right to think so. That's why there
   * are other tests.
   *
   * The first 4 indices are some special cases:
   *  - The very first one
   *  - The first one in the second column
   *  - The first one in the second row
   *  - The very last one.
   * The other 6 were randomly generated by Python.
   */
  unsigned int tests[10] = { 0, 64, 1024, 16383, 9177, 1342,
                             6600, 16334, 3257, 5906 };
  for(i = 0; i < 10; i++) {
    unsigned int val = tests[i];
    EXPECT_EQ(val, acc.getCoefficient(val)) << "Index " << val;
  }
  EXPECT_EQ(rows * cols * size, acc.getLength());
  deleteBlockArray(blocks, rows);
}

/**
 * Test to ensure that multiple components can be accessed.
 */
TEST_F(CoefficientAccessorTest, TestAccessMultipleComponents) {
  /* We'll have two 16x16 components and one 32x32 component */
  const int rows = 16, cols = 16, size = 64;
  int rowInfo[3] = { rows, rows, rows * 2};
  int colInfo[3] = { cols, cols, cols * 2};
  /**
   * This time our array is sorted, since that's what's required from
   * createRandomBlockArrays, but the four special cases from above are
   * included, as well as the following 4:
   * - The first coef in the second component (16384)
   * - The last coef in the second component (32767)
   * - The first coef in the third component (32768)
   * - The last coef altogether (98303)
   * The other 12 were randomly generated by Python.
   */
  unsigned int tests[20] = { 0, 64, 1024, 13320, 16383, 16384, 17399, 22661,
                             23006, 28042, 29460, 29624, 32767, 32768, 51230,
                             65105, 77865, 90453, 95958, 98303 };
  JCOEF values[20];
  int i;
  JBLOCKARRAY* b = createRandomBlockArrays(3, rowInfo, colInfo, tests, 20,
    values);
  DummyCoefficientsProvider p0(b[0]), p1(b[1]), p2(b[2]);
  JPEGComponent cmp0(cols, rows, cols * 8, rows * 8, 0, &p0),
                cmp1(cols, rows, cols * 8, rows * 8, 1, &p1),
                cmp2(cols * 2, rows * 2, cols * 16, rows * 16, 2, &p2);
  JPEGComponent *arr[3] = { &cmp0, &cmp1, &cmp2 };
  CoefficientAccessor acc(arr, 3);
  for(i = 0; i < 20; i++) {
    unsigned int index = tests[i];
    EXPECT_EQ(values[i], acc.getCoefficient(index)) << "Index " << index;
  }
  EXPECT_EQ((rows * cols * size) * 2 + (4 * rows * cols * 64),
    acc.getLength());
  deleteBlockArray(b[0], rows);
  deleteBlockArray(b[1], rows);
  deleteBlockArray(b[2], rows * 2);
  free(b);
}
